name: AI triage failed runs

on:
  workflow_run:
    workflows: ["build","ci","test","Deploy to Github Pages","Copilot Setup Steps"]
    types: [completed]

permissions:
  actions: read
  contents: read
  issues: write
  models: read

jobs:
  triage:
    if: ${{ github.event.workflow_run.conclusion == 'failure' }}
    runs-on: ubuntu-24.04
    env:
      PAT_WITH_ISSUES_WRITE: ${{ secrets.PAT_WITH_ISSUES_WRITE }}

    steps:
      # - name: Install GitHub CLI
      #   uses: cli/cli-action@v2

      - name: Set vars
        id: vars
        run: |
          echo "run_id=${{ github.event.workflow_run.id }}" >> $GITHUB_OUTPUT
          echo "run_url=${{ github.event.workflow_run.html_url }}" >> $GITHUB_OUTPUT
          echo "repo=${{ github.repository }}" >> $GITHUB_OUTPUT
          echo "branch=${{ github.event.workflow_run.head_branch }}" >> $GITHUB_OUTPUT
          echo "sha=${{ github.event.workflow_run.head_sha }}" >> $GITHUB_OUTPUT

      - name: Download logs (zip)
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          mkdir -p logs
          curl -sSL -H "Authorization: Bearer $GITHUB_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/${{ steps.vars.outputs.repo }}/actions/runs/${{ steps.vars.outputs.run_id }}/logs" \
            -o logs/run-logs.zip
          unzip -q logs/run-logs.zip -d logs || echo "No logs found."

      - name: Download test-results artifact
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          mkdir -p artifacts
          gh run download ${{ steps.vars.outputs.run_id }} \
            --repo "${{ steps.vars.outputs.repo }}" \
            -n "test-results" \
            -D artifacts/test-results || echo "No test-results artifact."

      - name: Parse TRX â†’ failures.md
        if: always()
        shell: pwsh
        run: |
          $trx = Get-ChildItem -Recurse artifacts/test-results -Filter *.trx -ErrorAction SilentlyContinue
          if (-not $trx) { "No TRX files found." | Out-File failures.md; exit 0 }

          $rows = @()
          foreach ($file in $trx) {
            [xml]$doc = Get-Content $file.FullName
            $ns = @{ a = $doc.DocumentElement.NamespaceURI }
            $failed = $doc.SelectNodes("//a:UnitTestResult[@outcome='Failed']", $ns)
            foreach ($r in $failed) {
              $out = $r.SelectSingleNode("a:Output", $ns)
              $msg = $out?.ErrorInfo?.Message
              $stack = $out?.ErrorInfo?.StackTrace
              $rows += [pscustomobject]@{
                Test=$r.testName; Duration=$r.duration
                Message=($msg -replace '\r','' -replace '\n',' ')
                Stack=($stack -replace '\r',''); File=$file.FullName
              }
            }
          }

          if (-not $rows) { "TRX present, but no failed tests." | Out-File failures.md; exit 0 }

          "# Failing tests" | Out-File failures.md
          "Total: $($rows.Count)" | Add-Content failures.md
          "" | Add-Content failures.md
          $rows | ForEach-Object {
            "### $($_.Test)" | Add-Content failures.md
            if ($_.Duration) { "- Duration: $($_.Duration)" | Add-Content failures.md }
            if ($_.Message)  { "- Error: $($_.Message)"     | Add-Content failures.md }
            if ($_.Stack)    { "````"; $_.Stack; "````"     | Add-Content failures.md }
            "- Source: $($_.File)" | Add-Content failures.md
            "" | Add-Content failures.md
          }

      - name: Build AI prompt (includes TRX + logs)
        run: |
          {
            echo "Failure in ${{ steps.vars.outputs.repo }} on branch ${{ steps.vars.outputs.branch }} at ${{ steps.vars.outputs.sha }}"
            echo "Run: ${{ steps.vars.outputs.run_url }}"
            echo
            echo "Goal: Summarise failure cause and propose next steps. Be concise and actionable."
            echo
            echo "=== Parsed test failures (TRX) ==="
            cat failures.md 2>/dev/null || echo "(no TRX parsed)"
            echo
            echo "=== Artifacts ==="
            find artifacts -type f -maxdepth 3 | sed 's/^/- /' || true
            echo
            echo "=== Logs (head) ==="
            find logs -type f -name '*.txt' | head -n 3 | xargs -r -I{} sh -c 'echo "--- {} ---"; head -n 60 "{}"'
            echo
            echo "=== Logs (tail) ==="
            find logs -type f -name '*.txt' | head -n 3 | xargs -r -I{} sh -c 'echo "--- {} ---"; tail -n 60 "{}"'
          } > prompt.txt

      - name: Call GitHub Models (chat completions)
        id: ai
        env:
          TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -e
          primary_model="openai/gpt-4o"
          fallback_model="openai/gpt-4o-mini"

          make_body() {
            jq -n \
              --arg model "$1" \
              --rawfile content prompt.txt \
              '{model: $model, messages: [{role:"system", content:"You are a senior CI engineer. Be concise."}, {role:"user", content:$content}]}'
          }

          # Try primary model first
          body=$(make_body "$primary_model")
          curl -sS https://models.github.ai/inference/chat/completions \
            -H "Authorization: Bearer $TOKEN" \
            -H "Accept: application/json" \
            -H "Content-Type: application/json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            -d "$body" | tee response.json

          # If API returns an error field, retry once with fallback model
          if jq -e '.error' response.json >/dev/null 2>&1; then
            echo "Primary model ($primary_model) unavailable: $(jq -r '.error.message // .error.code // "unknown"' response.json)" >&2
            body=$(make_body "$fallback_model")
            curl -sS https://models.github.ai/inference/chat/completions \
              -H "Authorization: Bearer $TOKEN" \
              -H "Accept: application/json" \
              -H "Content-Type: application/json" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              -d "$body" | tee response.json
          fi

          jq -r '.choices[0].message.content // empty' response.json > summary.md
          if [ ! -s summary.md ]; then echo "No AI summary produced" > summary.md; fi

      - name: Ensure labels exist
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh label create "ci-failure"   --repo "${{ steps.vars.outputs.repo }}" --color B60205 --description "CI pipeline failure"   2>/dev/null || true
          gh label create "needs-triage" --repo "${{ steps.vars.outputs.repo }}" --color D4C5F9 --description "Requires triage"       2>/dev/null || true

      - name: Create issue
        id: issue
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          title="CI failure: ${{ github.event.workflow_run.name }} on ${{ steps.vars.outputs.branch }}"
          body=$(printf "### AI summary\n\n%s\n\n---\n\nRun: %s\nCommit: %s\n" "$(cat summary.md)" "${{ steps.vars.outputs.run_url }}" "${{ steps.vars.outputs.sha }}")
          number=$(jq -n --arg t "$title" --arg b "$body" '{title:$t, body:$b, labels:["ci-failure","needs-triage"]}' \
            | gh api -X POST "repos/${{ steps.vars.outputs.repo }}/issues" --input - --jq '.number')
          echo "number=$number" >> "$GITHUB_OUTPUT"

      # Optional: assign to Copilot agent with a user PAT that can assign issues
      - name: Assign to Copilot coding agent (optional)
        if: ${{ env.PAT_WITH_ISSUES_WRITE != '' }}
        env:
          GH_TOKEN: ${{ secrets.PAT_WITH_ISSUES_WRITE }}
        run: |
          OWNER="${{ github.repository_owner }}"
          REPO="${{ github.event.repository.name }}"
          ISSUE_NUM="${{ steps.issue.outputs.number }}"

          ACTORS=$(gh api graphql -f owner="$OWNER" -f name="$REPO" -f query='
            query($owner:String!,$name:String!) {
              repository(owner:$owner, name:$name) {
                suggestedActors(capabilities:[CAN_BE_ASSIGNED], first:100) {
                  nodes { login __typename ... on Bot { id } ... on User { id } }
                }
              }
            }' || echo '{}')

          for login in copilot-swe-agent copilot-agent copilot; do
            BOT_ID=$(echo "$ACTORS" | jq -r --arg L "$login" '.data.repository.suggestedActors.nodes[] | select(.login==$L) | .id')
            [ -n "$BOT_ID" ] && break
          done
          if [ -z "$BOT_ID" ]; then echo "Copilot agent not suggested. Skipping."; exit 0; fi

          ISSUE_ID=$(gh api graphql -f owner="$OWNER" -f name="$REPO" -F num="$ISSUE_NUM" -f query='
            query($owner:String!,$name:String!,$num:Int!) {
              repository(owner:$owner, name:$name) { issue(number:$num) { id } }
            }' | jq -r '.data.repository.issue.id')

          gh api graphql -f id="$ISSUE_ID" -f actor="$BOT_ID" -f query='
            mutation($id:ID!,$actor:ID!){
              replaceActorsForAssignable(input:{assignableId:$id, actorIds:[$actor]}) {
                assignable { ... on Issue { id } }
              }
            }'
