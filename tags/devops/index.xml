<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>DevOps on Sujith Quintelier</title><link>https://quintelier.dev/tags/devops/</link><description>Recent content in DevOps on Sujith Quintelier</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Wed, 29 Oct 2025 06:00:00 +0000</lastBuildDate><atom:link href="https://quintelier.dev/tags/devops/index.xml" rel="self" type="application/rss+xml"/><item><title>Mastering Asynchronous Programming with C# async/await - Part 7: Testing &amp; Debugging</title><link>https://quintelier.dev/posts/2025/10/csharp-async-await-part7/</link><pubDate>Wed, 29 Oct 2025 06:00:00 +0000</pubDate><guid>https://quintelier.dev/posts/2025/10/csharp-async-await-part7/</guid><description>&lt;h2 id="part-7-testing-and-debugging-async-code">Part 7: Testing and Debugging Async Code&lt;/h2>
&lt;p>You‚Äôve learned how to &lt;em>write&lt;/em> async code ‚Äî but how do you &lt;strong>test&lt;/strong> it and &lt;strong>debug&lt;/strong> it when things go wrong? Async introduces unique challenges: hidden continuations, exceptions in background tasks, and ‚Äúlost‚Äù operations. Let‚Äôs tackle them.&lt;/p>
&lt;hr>
&lt;h2 id="writing-async-unit-tests">Writing Async Unit Tests&lt;/h2>
&lt;p>Most modern test frameworks (xUnit, NUnit, MSTest) fully support async tests.&lt;/p>
&lt;p>‚úÖ Correct:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">[Fact]&lt;/span> &lt;span style="color:#75715e">// xUnit&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">async&lt;/span> Task GetNumberAsync_Returns42()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> result = &lt;span style="color:#66d9ef">await&lt;/span> GetNumberAsync();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Assert.Equal(&lt;span style="color:#ae81ff">42&lt;/span>, result);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>‚ö†Ô∏è Avoid this (blocks async code and may deadlock):&lt;/p></description></item><item><title>Mastering Asynchronous Programming with C# async/await - Part 6: Advanced Topics</title><link>https://quintelier.dev/posts/2025/10/csharp-async-await-part6/</link><pubDate>Wed, 22 Oct 2025 06:00:00 +0000</pubDate><guid>https://quintelier.dev/posts/2025/10/csharp-async-await-part6/</guid><description>&lt;h2 id="part-6-advanced-topics">Part 6: Advanced Topics&lt;/h2>
&lt;p>Now that we‚Äôve mastered the basics and patterns, let‚Äôs go further into &lt;strong>advanced async scenarios&lt;/strong> you‚Äôll meet when optimizing throughput or designing libraries.&lt;/p>
&lt;hr>
&lt;h2 id="valuetask-vs-task">&lt;code>ValueTask&lt;/code> vs &lt;code>Task&lt;/code>&lt;/h2>
&lt;p>&lt;code>Task&lt;/code> is a reference type allocated on the heap. In ultra‚Äëhot paths where many calls &lt;strong>complete synchronously&lt;/strong>, &lt;code>ValueTask&lt;/code> can save allocations.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">async&lt;/span> ValueTask&amp;lt;&lt;span style="color:#66d9ef">int&lt;/span>&amp;gt; GetNumberAsync(&lt;span style="color:#66d9ef">bool&lt;/span> cached)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (cached) &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">42&lt;/span>; &lt;span style="color:#75715e">// completes synchronously (no allocation)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">await&lt;/span> Task.Delay(&lt;span style="color:#ae81ff">1000&lt;/span>); &lt;span style="color:#75715e">// completes asynchronously&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">42&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>Guidelines&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Prefer &lt;code>Task&lt;/code> by default (simpler, safer).&lt;/li>
&lt;li>Consider &lt;code>ValueTask&lt;/code> when profiling shows allocation pressure and many sync completions.&lt;/li>
&lt;li>Don‚Äôt await a &lt;code>ValueTask&lt;/code> more than once and don‚Äôt store it; convert to &lt;code>Task&lt;/code> via &lt;code>.AsTask()&lt;/code> if you must pass it around.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="custom-awaiters-rare-but-educational">Custom Awaiters (rare, but educational)&lt;/h2>
&lt;p>Anything with a &lt;code>GetAwaiter()&lt;/code> that returns an awaiter implementing &lt;code>INotifyCompletion&lt;/code> (or &lt;code>ICriticalNotifyCompletion&lt;/code>) is awaitable.&lt;/p></description></item><item><title>Mastering Asynchronous Programming with C# async/await - Part 5: Real-World Use Cases</title><link>https://quintelier.dev/posts/2025/10/csharp-async-await-part5/</link><pubDate>Wed, 15 Oct 2025 06:00:00 +0000</pubDate><guid>https://quintelier.dev/posts/2025/10/csharp-async-await-part5/</guid><description>&lt;h2 id="part-5-real-world-use-cases">Part 5: Real-World Use Cases&lt;/h2>
&lt;p>We‚Äôve covered the foundations, pitfalls, and async patterns. Now let‚Äôs see how &lt;code>async&lt;/code>/&lt;code>await&lt;/code> shows up in &lt;strong>real applications&lt;/strong> ‚Äî from APIs to UI apps.&lt;/p>
&lt;hr>
&lt;h2 id="use-case-1-calling-web-apis-with-httpclient">Use Case 1: Calling Web APIs with &lt;code>HttpClient&lt;/code>&lt;/h2>
&lt;p>&lt;code>HttpClient&lt;/code> is fully async, making it ideal for network calls.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">async&lt;/span> Task GetWeatherAsync()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> client = &lt;span style="color:#66d9ef">new&lt;/span> HttpClient();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> response = &lt;span style="color:#66d9ef">await&lt;/span> client.GetStringAsync(&lt;span style="color:#e6db74">&amp;#34;https://api.weather.com/data&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Console.WriteLine(response);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>This avoids blocking threads while waiting for the response.&lt;/p></description></item><item><title>Mastering Asynchronous Programming with C# async/await - Part 4: Patterns with Async</title><link>https://quintelier.dev/posts/2025/10/csharp-async-await-part4/</link><pubDate>Wed, 08 Oct 2025 06:00:00 +0000</pubDate><guid>https://quintelier.dev/posts/2025/10/csharp-async-await-part4/</guid><description>&lt;h2 id="part-4-patterns-with-async">Part 4: Patterns with Async&lt;/h2>
&lt;p>So far, we‚Äôve looked at the basics and pitfalls of &lt;code>async&lt;/code>/&lt;code>await&lt;/code>. Now let‚Äôs move to &lt;strong>patterns&lt;/strong> that help you handle real-world scenarios like parallelism, cancellation, streaming, and timeouts.&lt;/p>
&lt;hr>
&lt;h2 id="pattern-1-running-tasks-in-parallel">Pattern 1: Running Tasks in Parallel&lt;/h2>
&lt;p>Sometimes you want to start multiple operations and wait for all of them.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">async&lt;/span> Task FetchInParallelAsync()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> client = &lt;span style="color:#66d9ef">new&lt;/span> HttpClient();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> task1 = client.GetStringAsync(&lt;span style="color:#e6db74">&amp;#34;https://example.com/page1&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> task2 = client.GetStringAsync(&lt;span style="color:#e6db74">&amp;#34;https://example.com/page2&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> results = &lt;span style="color:#66d9ef">await&lt;/span> Task.WhenAll(task1, task2);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Console.WriteLine(&lt;span style="color:#e6db74">$&amp;#34;Page1 length: {results[0].Length}&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Console.WriteLine(&lt;span style="color:#e6db74">$&amp;#34;Page2 length: {results[1].Length}&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>‚úÖ &lt;strong>Use &lt;code>Task.WhenAll&lt;/code>&lt;/strong> when you need &lt;em>all&lt;/em> tasks to finish.&lt;br>
‚úÖ &lt;strong>Use &lt;code>Task.WhenAny&lt;/code>&lt;/strong> when you only care about the first result:&lt;/p></description></item><item><title>Mastering Asynchronous Programming with C# async/await - Part 3: Common Pitfalls and Best Practices</title><link>https://quintelier.dev/posts/2025/10/csharp-async-await-part3/</link><pubDate>Wed, 01 Oct 2025 06:00:00 +0000</pubDate><guid>https://quintelier.dev/posts/2025/10/csharp-async-await-part3/</guid><description>&lt;h2 id="part-3-common-pitfalls--best-practices">Part 3: Common Pitfalls &amp;amp; Best Practices&lt;/h2>
&lt;p>By now, you know how &lt;code>async&lt;/code>/&lt;code>await&lt;/code> works and how to run tasks sequentially or in parallel. But async programming in C# has some traps that can lead to &lt;strong>deadlocks, unhandled exceptions, or subtle bugs&lt;/strong>.&lt;/p>
&lt;p>Let‚Äôs go through the most common pitfalls and how to avoid them.&lt;/p>
&lt;hr>
&lt;h2 id="pitfall-1-async-void">Pitfall 1: &lt;code>async void&lt;/code>&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">async&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> DoWork()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">await&lt;/span> Task.Delay(&lt;span style="color:#ae81ff">1000&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Exception(&lt;span style="color:#e6db74">&amp;#34;Boom!&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Why it‚Äôs bad:&lt;/p>
&lt;ul>
&lt;li>You &lt;strong>can‚Äôt await&lt;/strong> it ‚Üí no way to know when it‚Äôs done.&lt;/li>
&lt;li>Exceptions go directly to the &lt;strong>synchronization context&lt;/strong> (e.g., crash the app).&lt;/li>
&lt;/ul>
&lt;p>‚úÖ &lt;strong>Best practice&lt;/strong>:&lt;/p></description></item><item><title>ü§ñ Automating Dependabot at Scale: GitHub Actions Strategy</title><link>https://quintelier.dev/posts/2025/09/automating-dependabot-at-scale-github-actions-strategy/</link><pubDate>Tue, 30 Sep 2025 06:00:00 +0000</pubDate><guid>https://quintelier.dev/posts/2025/09/automating-dependabot-at-scale-github-actions-strategy/</guid><description>&lt;h2 id="the-challenge-the-90-day-dependabot-pause">The Challenge: The 90-Day Dependabot Pause&lt;/h2>
&lt;p>If you&amp;rsquo;re managing multiple repositories in a GitHub organization, you&amp;rsquo;ve likely encountered a frustrating limitation: &lt;strong>Dependabot automatically pauses after 90 days of inactivity&lt;/strong>. When there are no merged pull requests or manual triggers, Dependabot simply stops creating new dependency updates. For organizations with dozens or hundreds of repositories, this can lead to a security and maintenance nightmare.&lt;/p>
&lt;p>The problem compounds quickly:&lt;/p>
&lt;ul>
&lt;li>Some repositories might be stable but still need security updates&lt;/li>
&lt;li>Manual intervention across many repos is time-consuming and error-prone&lt;/li>
&lt;li>By the time you notice Dependabot has paused, you&amp;rsquo;re already behind on updates&lt;/li>
&lt;li>Re-enabling requires manual UI interaction for each repository&lt;/li>
&lt;/ul>
&lt;h2 id="the-solution-a-two-pronged-automation-strategy">The Solution: A Two-Pronged Automation Strategy&lt;/h2>
&lt;p>This comprehensive GitHub Actions workflow system tackles this problem through both &lt;strong>proactive prevention&lt;/strong> and &lt;strong>early detection&lt;/strong>. Let me walk you through how it works.&lt;/p></description></item><item><title>Mastering Asynchronous Programming with C# async/await - Part 2: Deep Dive</title><link>https://quintelier.dev/posts/2025/09/csharp-async-await-part2/</link><pubDate>Wed, 24 Sep 2025 06:00:00 +0000</pubDate><guid>https://quintelier.dev/posts/2025/09/csharp-async-await-part2/</guid><description>&lt;h2 id="part-2-deep-dive-into-async-and-await">Part 2: Deep Dive into &lt;code>async&lt;/code> and &lt;code>await&lt;/code>&lt;/h2>
&lt;p>In Part 1, we saw why asynchronous programming matters and how &lt;code>async&lt;/code>/&lt;code>await&lt;/code> can make our apps more responsive. Now it‚Äôs time to &lt;strong>go deeper&lt;/strong> into how it actually works.&lt;/p>
&lt;hr>
&lt;h2 id="anatomy-of-an-async-method">Anatomy of an &lt;code>async&lt;/code> Method&lt;/h2>
&lt;p>Let‚Äôs look at a simple method:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">async&lt;/span> Task DoWorkAsync()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Console.WriteLine(&lt;span style="color:#e6db74">&amp;#34;Step 1: Start work&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">await&lt;/span> Task.Delay(&lt;span style="color:#ae81ff">2000&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Console.WriteLine(&lt;span style="color:#e6db74">&amp;#34;Step 2: Work complete&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Breaking it down:&lt;/p></description></item><item><title>Mastering Asynchronous Programming with C# async/await</title><link>https://quintelier.dev/posts/2025/09/csharp-async-await/</link><pubDate>Wed, 17 Sep 2025 06:00:00 +0000</pubDate><guid>https://quintelier.dev/posts/2025/09/csharp-async-await/</guid><description>&lt;h2 id="complete-7-part-series">Complete 7-Part Series&lt;/h2>
&lt;h3 id="series-navigation">Series Navigation&lt;/h3>
&lt;ol>
&lt;li>&lt;a href="https://quintelier.dev/posts/2025/09/csharp-async-await-part1/">Part 1 ‚Äì Introduction&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://quintelier.dev/posts/2025/09/csharp-async-await-part2/">Part 2 ‚Äì Deep Dive&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://quintelier.dev/posts/2025/10/csharp-async-await-part3/">Part 3 ‚Äì Pitfalls &amp;amp; Best Practices&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://quintelier.dev/posts/2025/10/csharp-async-await-part4/">Part 4 ‚Äì Patterns&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://quintelier.dev/posts/2025/10/csharp-async-await-part5/">Part 5 ‚Äì Real-World Use Cases&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://quintelier.dev/posts/2025/10/csharp-async-await-part6/">Part 6 ‚Äì Advanced Topics&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://quintelier.dev/posts/2025/10/csharp-async-await-part7/">Part 7 ‚Äì Testing &amp;amp; Debugging&lt;/a>&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>Asynchronous programming is one of the most powerful features in modern C#. It keeps your applications &lt;strong>responsive, scalable, and efficient&lt;/strong> ‚Äî but it can also be tricky to master.&lt;/p></description></item><item><title>Mastering Asynchronous Programming with C# async/await - Part 1: Introduction</title><link>https://quintelier.dev/posts/2025/09/csharp-async-await-part1/</link><pubDate>Wed, 17 Sep 2025 06:00:00 +0000</pubDate><guid>https://quintelier.dev/posts/2025/09/csharp-async-await-part1/</guid><description>&lt;h2 id="part-1-introduction-to-asynchronous-programming">Part 1: Introduction to Asynchronous Programming&lt;/h2>
&lt;p>When you build applications in C#, one of the biggest challenges is making them &lt;strong>fast and responsive&lt;/strong>. Whether you‚Äôre writing a desktop app that must keep its UI smooth, a web API that needs to handle thousands of requests, or a service that integrates with multiple external systems, &lt;strong>asynchronous programming&lt;/strong> is key.&lt;/p>
&lt;p>But async/await can feel like magic ‚ú®. Let‚Äôs break it down step by step.&lt;/p></description></item><item><title>Taming Dependabot: Bundle NuGet, npm, and GitHub Actions Updates Without Merge Conflicts</title><link>https://quintelier.dev/posts/2025/09/taming-dependabot-bundle-nuget-npm-github-actions-updates-without-merge-conflicts/</link><pubDate>Tue, 16 Sep 2025 06:00:00 +0000</pubDate><guid>https://quintelier.dev/posts/2025/09/taming-dependabot-bundle-nuget-npm-github-actions-updates-without-merge-conflicts/</guid><description>&lt;p>If you‚Äôve enabled &lt;strong>Dependabot&lt;/strong>, you probably love the automated updates but not the &lt;strong>PR storm&lt;/strong> and the &lt;strong>merge conflicts&lt;/strong> that happen when several PRs touch the same lockfiles or project files.&lt;/p>
&lt;p>The cure is &lt;strong>Dependabot Groups&lt;/strong>: batch related updates into a single PR so you merge once and move on.&lt;/p>
&lt;hr>
&lt;h2 id="why-conflicts-happen">Why conflicts happen&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>npm&lt;/strong>: multiple PRs each rewrite &lt;code>package-lock.json&lt;/code>.&lt;/li>
&lt;li>&lt;strong>NuGet&lt;/strong>: several PRs change the same &lt;code>.csproj&lt;/code> / &lt;code>packages.lock.json&lt;/code>.&lt;/li>
&lt;li>&lt;strong>GitHub Actions&lt;/strong>: many small PRs bumping actions across several workflow files.&lt;/li>
&lt;/ul>
&lt;p>Merge one PR ‚Üí the others go stale ‚Üí conflicts or repeated rebases.&lt;/p></description></item><item><title>Platform Engineering Course Guide üöÄ</title><link>https://quintelier.dev/posts/2025/08/platform-engineering-certified-practitioner/</link><pubDate>Fri, 22 Aug 2025 09:00:00 +0000</pubDate><guid>https://quintelier.dev/posts/2025/08/platform-engineering-certified-practitioner/</guid><description>&lt;h2 id="mastering-platform-engineering-from-golden-paths-to-selling-your-mvp">Mastering Platform Engineering: From Golden Paths to Selling Your MVP&lt;/h2>
&lt;p>Platform engineering is no longer a buzzword: it‚Äôs a proven practice that bridges the gap between developers and operations by building Internal Developer Platforms (IDPs). As &lt;a href="https://www.gartner.com/en/articles/what-is-platform-engineering" target="_blank" rel="noopener noreferrer">Gartner&lt;/a> predicts, by 2026, 80% of large software engineering organisations will establish platform engineering teams as internal providers of reusable services, components, and tools for application delivery.&lt;/p>
&lt;p>The &lt;strong>Platform Engineering Certified Practitioner&lt;/strong> course equips engineers, architects, and technology leaders with the knowledge and hands-on frameworks to design, build, and scale successful platforms inside their organisations.&lt;/p></description></item><item><title>üöÄ GitHub Actions Certification Guide (GH-200) - Complete Prep</title><link>https://quintelier.dev/posts/2025/08/github-certification-journey-gh-200/</link><pubDate>Fri, 22 Aug 2025 06:00:00 +0000</pubDate><guid>https://quintelier.dev/posts/2025/08/github-certification-journey-gh-200/</guid><description>&lt;h2 id="introduction">Introduction&lt;/h2>
&lt;p>Welcome to Part 3 of the &lt;strong>GitHub Certification Journey&lt;/strong>! üéØ&lt;/p>
&lt;p>After mastering GitHub Foundations (GH-900) and GitHub Administration (GH-100), you&amp;rsquo;re ready to dive deep into &lt;strong>GitHub Actions&lt;/strong> - the powerhouse automation platform that transforms how teams build, test, and deploy software. The &lt;strong>GH-200 GitHub Actions&lt;/strong> certification validates your ability to design, implement, and manage CI/CD pipelines at enterprise scale.&lt;/p>
&lt;p>This comprehensive guide provides everything needed to pass the GH-200 exam and become a GitHub Actions expert. Whether you&amp;rsquo;re a DevOps engineer, platform team member, or developer looking to automate workflows, this preparation roadmap will take you from YAML basics to advanced enterprise automation patterns.&lt;/p></description></item><item><title>‚öôÔ∏è Automated Updates Pipeline</title><link>https://quintelier.dev/posts/2025/08/automated-updates-pipeline/</link><pubDate>Wed, 13 Aug 2025 06:00:00 +0000</pubDate><guid>https://quintelier.dev/posts/2025/08/automated-updates-pipeline/</guid><description>&lt;h2 id="why-this-pipeline-exists">Why this pipeline exists&lt;/h2>
&lt;p>Manually curating weekly platform updates (Azure service changes, GitHub changelog entries, Terraform provider releases) is repetitive, time‚Äësensitive, and error‚Äëprone. This pipeline automates the whole path from data acquisition ‚Üí AI summarisation ‚Üí Hugo markdown generation ‚Üí commit, delivering consistent, timestamped update posts under &lt;code>content/updates&lt;/code>.&lt;/p>
&lt;h2 id="highlevel-architecture">High‚Äëlevel architecture&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê cron 05:15 UTC ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê grouped items ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>‚îÇ GitHub Action ‚îÇ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ&amp;gt; ‚îÇ PowerShell Script ‚îÇ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ&amp;gt; ‚îÇ AI Summarisation ‚îÇ
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ‚îÇ commit (if changed) ‚îÇ filtered items ‚îÇ summaries
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> V V V
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Repo content &amp;lt;‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ write markdown posts &amp;lt;‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ assemble front matter
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="scheduling--cadence">Scheduling &amp;amp; cadence&lt;/h2>
&lt;p>The workflow runs daily at &lt;code>05:15 UTC&lt;/code> but per‚Äësource publication cadence is controlled inside the script using a frequency map (&lt;code>Azure=weekly,GitHub=weekly,Terraform=weekly&lt;/code> by default). The script:&lt;/p></description></item><item><title>üêô GitHub Certification Journey: Part 1 - GitHub Foundations (GH-900)</title><link>https://quintelier.dev/posts/2025/08/github-certification-journey-gh-900/</link><pubDate>Fri, 08 Aug 2025 06:00:00 +0000</pubDate><guid>https://quintelier.dev/posts/2025/08/github-certification-journey-gh-900/</guid><description>&lt;p>Welcome to the GitHub Certification Journey! This comprehensive guide covers everything you need to master the &lt;strong>GitHub Foundations (GH-900)&lt;/strong> certification. Whether you&amp;rsquo;re new to Git and GitHub or looking to validate your foundational knowledge, this post provides complete coverage of all exam domains with practical examples and hands-on exercises.&lt;/p>
&lt;h2 id="why-github-foundations-certification-matters">Why GitHub Foundations Certification Matters&lt;/h2>
&lt;p>The GitHub Foundations certification validates your understanding of Git version control and GitHub collaboration fundamentals. As the entry point to GitHub&amp;rsquo;s certification pathway, it demonstrates your ability to:&lt;/p></description></item><item><title>üîÑ GitHub updates for March 14, 2025</title><link>https://quintelier.dev/posts/2025/03/github-updates-march-14-2025/</link><pubDate>Fri, 14 Mar 2025 06:00:00 +0000</pubDate><guid>https://quintelier.dev/posts/2025/03/github-updates-march-14-2025/</guid><description>&lt;h2 id="introduction-github-changelog--latest-updates--enhancements">&lt;strong>Introduction: GitHub Changelog ‚Äì Latest Updates &amp;amp; Enhancements&lt;/strong>&lt;/h2>
&lt;p>Stay up to date with the latest &lt;strong>GitHub updates, features, and improvements&lt;/strong> designed to enhance your development experience. Whether it‚Äôs &lt;strong>security and compliance advancements&lt;/strong>, &lt;strong>performance optimizations&lt;/strong>, or &lt;strong>new tools for automation and insights&lt;/strong>, this changelog keeps you informed about what‚Äôs new and how it can benefit your workflow.&lt;/p>
&lt;p>In this edition, we‚Äôre covering &lt;strong>GitHub‚Äôs PCI DSS v4.0 compliance&lt;/strong> for enterprise customers and the &lt;strong>general availability of GitHub Actions Performance Metrics&lt;/strong>, helping teams gain deeper insights into their CI/CD workflows. Let‚Äôs dive into the details! üöÄ&lt;/p></description></item><item><title>üöÄ Find Stale Branches Across All GitHub Repos</title><link>https://quintelier.dev/posts/2025/01/retrieve-stale-branches-github-organization/</link><pubDate>Tue, 14 Jan 2025 06:00:00 +0000</pubDate><guid>https://quintelier.dev/posts/2025/01/retrieve-stale-branches-github-organization/</guid><description>&lt;p>Keeping your GitHub repositories clean is crucial for maintainability. Over time, branches pile up, making it difficult to track what‚Äôs relevant. If you‚Äôre managing multiple repositories in an organization, manually identifying stale branches can be a hassle.&lt;/p>
&lt;p>Luckily, with the &lt;strong>GitHub CLI (&lt;code>gh&lt;/code>)&lt;/strong>, you can automate this process and generate a &lt;strong>report of all non-main branches along with their last authors&lt;/strong>.&lt;/p>
&lt;p>This guide walks you through a &lt;strong>Bash script&lt;/strong> that:&lt;br>
‚úÖ Retrieves all repositories in an organization&lt;br>
‚úÖ Lists branches, excluding &lt;code>main&lt;/code>, &lt;code>master&lt;/code>, and &lt;code>azure-master&lt;/code>&lt;br>
‚úÖ Identifies the last commit author for each branch&lt;br>
‚úÖ Groups the results by author for better visibility&lt;/p></description></item></channel></rss>